% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Methoden (fortgeschritten)}
\date{\today}


\begin{document}

\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}

% ----------------------- Extensions ------------------------------
\section{Extensions}
\begin{frame}{Extensions}
	\begin{itemize}
		\item Ermöglichen es vorhandenen Typen eigene Methoden hinzuzufügen
		\item Ohne eine abgeleitete Klasse zu erstellen oder den originalen Typen neu zu erstellen
		\item Sind statische Methoden, welche aber als Instanzmethoden auf den erweiterten Typ agieren
		\item Befinden sich selbst in einer extra statischen Klasse
		\item Syntax:
		\begin{itemize}
			\item \texttt{public static \alert{<Rückgabetyp> <Name>}( this \alert{<Erweiterter Typ> <Variablenname>}, \alert{[Übergabeparameter]} )\\ \{ \alert{<Code>} \}}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Extensions}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/extensions.cs}
\end{frame}

% ----------------------- Opertatoren Überladung ------------------------------
\section{Opertatoren Überladung}
\begin{frame}{Opertatoren Überladung}
	\begin{itemize}
		\item Alle Typen können statische Methoden haben, welche Operatoren überschreiben und neu definieren können
		\item Nicht alle Operatoren können überschrieben werden
		\item Syntax:
		\begin{itemize}
			\item \texttt{public static \alert{<Datentyp>} operator \alert{<Operator>}\\( \alert{[Übergabeparameter]} ) \{ \alert{<Code>} \}}
		\end{itemize}
		\item Verschiedene Operatoren brauchen verschiedene Übergabeparameter und Rückgabeparameter
	\end{itemize}
\end{frame}

\begin{frame}{Opertatoren Überladung}
	\textbf{Operatoren}\\
	\begin{description}
		\item[unäre] \alert{\texttt{+}}, \alert{\texttt{-}}, \alert{\texttt{!}}, \alert{\texttt{\~}}, \alert{\texttt{++}}, \alert{\texttt{--}}, \alert{\texttt{true}}, \alert{\texttt{false}}
		\item[binär] \alert{\texttt{+}}, \alert{\texttt{-}}, \alert{\texttt{*}}, \alert{\texttt{/}}, \alert{\texttt{\%}}, \alert{\texttt{\&}}, \alert{\texttt{|}}, \alert{\texttt{\^}}, \alert{\texttt{<<}}, \alert{\texttt{>>}}
		\item[vergleich]  \alert{\texttt{==}}, \alert{\texttt{!=}}, \alert{\texttt{<}}, \alert{\texttt{>}}, \alert{\texttt{<=}}, \alert{\texttt{>=}}
	\end{description}
	\begin{itemize}
		\item Andere Operatoren können nicht überschrieben werden
		\item Operatoren wie \alert{+=} und \alert{\&\&} werden durch \alert{+} und \alert{\&} beschrieben
		\item \alert{true} und \alert{false} geben dem Objekt die Möglichkeit wie bool behandelt zu werden
		\item Bei Vergleichoperatoren muss der jeweilige Gegensatz auch überschrieben werden (z.B. bei \alert{==} auch \alert{!=} überschreiben)
	\end{itemize}
\end{frame}

\begin{frame}{Opertatoren Überladung}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/operation_overload_creation.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/operation_overload_using.cs}
\end{frame}

% ----------------------- delegate ------------------------------
\section{delegate}
\begin{frame}{delegate}
	\begin{itemize}
		\item Schlüsselwort zur Erstellung eines Datentypes zur Speicherung von Methoden
		\item Es weiß, welche Rückgabetype und Übergabeparameter die Methoden brauchen
		\item In einer Variable eines Delegate können verschiedene Methoden gespeichert und gleichzeitig aufgerufen werden
		\item Syntax:
		\begin{itemize}
			\item \texttt{delegate \alert{<Rückgabetyp> <Variablenname>}\\( \alert{[Übergabeparameter]} );}
		\end{itemize}
		\item Variable wird genauso genutzt wie eine normale Methode
		\begin{itemize}
			\item Falls diese Variable leer ist, wird ein Fehler geworfen
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{delegate}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/delegate_creation.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/delegate_using.cs}
\end{frame}

% ----------------------- Anonyme Methoden ------------------------------
\section{Anonyme Methoden}
\begin{frame}{Anonyme Methoden}
	\begin{itemize}
		\item Haben keinen eigenen Methodenkopf
		\item Können nur durch Delegate-Variablen aufgerufen und genutzt werden
		\item Es gibt 2 Artern der Erstellung:
		\begin{itemize}
			\item Durch Schlüsselwort \alert{delegate}
			\item Über Lamda-Terme
		\end{itemize}	
	\end{itemize}
\end{frame}

\subsection{delegate}
\begin{frame}{delegate}
	\begin{itemize}
		\item \alert{delegate} kann auch als Methodendefinition genutzt werden
		\item Syntax:
		\begin{itemize}
			\item \texttt{\alert{<Delegate-Variable>} = \\delegate( \alert{[Übergabeparameter]} ) \{ \alert{<Code>} \};}
		\end{itemize}
	\end{itemize}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/anonym_method_delegate_creation.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/anonym_method_delegate_using.cs}	
\end{frame}

\subsection{Lamda}
\begin{frame}{Lamda}
	\begin{itemize}
		\item Benutzt den Lamda-Operator \alert{\texttt{=>}}
		\item Syntax:
		\begin{itemize}
			\item \texttt{( \alert{[Übergabeparameter]} ) => \{ \alert{<Code>} \};}
			\item Es gibt Unterschiede in der Syntax zwischen den einzelnen Lamda Arten
			\item Übergabeparameter brauchen nicht immer einen Typ, da dieser hergeleitet werden kann
		\end{itemize}
	\end{itemize}
\end{frame}

\subsubsection{Ausdruck-Lamdas}
\begin{frame}{Ausdruck-Lamdas}
	\begin{itemize}
		\item Besitzt im Körper nur einen Ausdruck und braucht somit keine geschweiften Klammern
		\item Gibt als Ergebnis das Ergebnis des einen Ausdrucks zurück
	\end{itemize}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/anonym_method_delegate_creation_2.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/expression_lamda.cs}	
\end{frame}

\subsubsection{Anweisung-Lamdas}
\begin{frame}{Anweisung-Lamdas}
	\begin{itemize}
		\item Haben mehrere Ausdrücke (meist höchstens 2 oder 3) und haben geschweifte Klammern		
	\end{itemize}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/anonym_method_delegate_creation_3.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/statement_lamda.cs}
\end{frame}

\subsubsection{Variablenbereich für Lamdas}
\begin{frame}{Variablenbereich für Lamdas}
	\begin{itemize}
		\item Lamdas können auf Variablen außerhalb verweisen und diese nutzen
		\item Diese werden zur Verwendung im Lamda gespeichert
		\item So eine aüßere Variable muss definitiv vorher zugewiesen sein
	\end{itemize}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/anonym_method_delegate_creation_3.cs}
\end{frame}

\begin{frame}{Variablenbereich für Lamdas}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/variable_scope_lamda.cs}
\end{frame}

% ----------------------- Schlüsselwörter ------------------------------
\section{Schlüsselwörter}
\begin{frame}{Schlüsselwörter}
	\textbf{ref}\\
	\begin{itemize}
		\item Ermöglicht es einen Werttyp (wie z.B. int) als Referenztyp in eine Methode zu übergeben
		\item Wird dabei vor den Datentyp eines Übergabeparameters
		\item Und beim Aufruf vor die Variable geschrieben
	\end{itemize}
	\textbf{params}\\
	\begin{itemize}
		\item Ermöglicht es eine beliebige Anzahl von Übergabeparametern eines Typs einer Methode zu geben
		\item Diese werden in der Methode dann als Array genutzt
		\item Die Übergabe kann über eine mit Komma getrennte Liste oder über ein Array passieren
	\end{itemize}
\end{frame}

\begin{frame}{Schlüsselwörter}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/ref_param_creation.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/ref_param_using.cs}
\end{frame}

\begin{frame}{Schlüsselwörter}
	\textbf{out}\\
	\begin{itemize}
		\item Eine Variable wird, wie bei \alert{ref}, als Verweis übergeben
		\item Jedoch muss diese Variable nun nicht deklariert sein
		\item Die Methode wird dann gezwungen während ihrer Ausführung der \alert{out}-Variable etwas zuzuweisen
	\end{itemize}
\end{frame}

\begin{frame}{Schlüsselwörter}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/out_creation.cs}
	\lstinputlisting{resources/07_Methoden_fortgeschritten/out_using.cs}
\end{frame}

\end{document}
