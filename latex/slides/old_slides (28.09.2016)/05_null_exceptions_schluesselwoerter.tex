% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
% TODO Change the topic of the lesson
\title{Null, Exceptions und Schlüsselwörter}
\date{\today}


\begin{document}

\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}


% ----------------------- Exceptions ------------------------------
\section{Exceptions}
\begin{frame}{Exceptions}
	\begin{itemize}
		\item Zu dt. Ausnahmen
		\item Zeigt an, dass ein außergewöhnlicher oder unerwarteter Programmzustand eingetreten ist
		\item Beinhalten Information über Art und Auftreten des Fehlers
		\item Es gibt verschiedene Arten, wie z.B.:
		\begin{itemize} 
			\item ArgumentException
			\item NullReferenceException	
			\item FileNotFoundException
		\end{itemize}
		\item Exception welche nicht behandelt wurden, führen zum Absturz des Programms
	\end{itemize}
\end{frame}

\subsection{Handling}
\begin{frame}{Handling}
	\textbf{try catch finally}\\
	\begin{itemize}
		\item Wird genutzt um Exceptions aufzufangen und diese zu behandeln
		\item Der im \alert{try}-Block stehende Code wird ausgeführt und bei auftreten einer Exception werden die \alert{catch}-Blöcke ausgeführt
		\item Es kann mehrere \alert{catch}-Blöcke für verschiedene Exception geben
		\begin{itemize}
			\item Die Exception kann im \alert{catch}-Block als Variable genutzt werde
			\item Man geht immer vom spezifischen zum allgemeinem Fehler, damit alle Exceptions gefangen werden können
		\end{itemize}
		\item Der \alert{finally}-Block wird immer ausgeführt, auch wenn keine Exception aufgetreten ist
		\begin{itemize}
			\item Wird auch Bereinigungsblock genannt
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Handling}
	\lstinputlisting{resources/05_null_exceptions_schluesselwoerter/exception_handling.cs}	
\end{frame}

\subsection{Eigene Exceptions}
\begin{frame}{Eigene Exceptions}
	\textbf{throw}\\
	\begin{itemize}
		\item Schlüsselwort um eine Exception zu werfen/auszulösen
		\item Syntax:
		\begin{itemize}
			\item \texttt{throw new \alert{<Exceptionkonstruktor>}(\alert{[Parameter]});}
		\end{itemize}
	\end{itemize}
	\textbf{Eigene Exception}\\
	\begin{itemize}
		\item Man kann eine eigene Excpetion-Klasse schreiben, in dem man von der Klasse \alert{System.Exception} erbt
	\end{itemize}
\end{frame}

\begin{frame}{Eigene Exceptions}
	\lstinputlisting{resources/05_null_exceptions_schluesselwoerter/exception_throw.cs}
\end{frame}

% ----------------------- null ------------------------------
\section{null}
\begin{frame}{null}
	\begin{itemize}
		\item Schlüsselwort für eine Referenz die auf kein Objekt zeigt
		\item Alle Referenztyp-Variablen können \alert{null} sein
		\item Versucht man ein \alert{null} Objekt zu dereferenzieren, wird eine NullReferenceException geworfen 
		\begin{itemize}
			\item Es ist möglich ein Objekt auf eine \alert{null} Referenz zu prüfen
		\end{itemize}
	\end{itemize}
	\lstinputlisting{resources/05_null_exceptions_schluesselwoerter/null.cs}	
\end{frame}

\subsection{Nullable}
\begin{frame}{Nullable}
	\begin{itemize}
		\item Werden genutzt, damit Werttyp-Variablen ebenfalls \alert{null} haben können
		\item Besitzt 2 Eigenschaften
		\begin{description}
			\item[HasValue] Gibt an, ob das Objekt einen Wert hat oder nicht
			\item[Value] Gibt den Wert des Objektes zurück\\ Wirft eine InvalidOperationException falls HasValue \alert{false} ist 
		\end{description}
		\item Syntax:
		\begin{itemize}
			\item \texttt{\alert{<Werttyp>}? \alert{<Variablenname>};} oder
			\item \texttt{Nullable<\alert{<Datentyp>}> \alert{<Variablenname>};}
			\begin{itemize}
				\item Das ist ein Generic
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Nullable}
	\lstinputlisting{resources/05_null_exceptions_schluesselwoerter/nullable.cs}	
\end{frame}

% ----------------------- Schlüsselwörter ------------------------------
\section{Schlüsselwörter}
\begin{frame}{Schlüsselwörter}
	\textbf{static}\\
	\begin{itemize}
		\item Es können Klassen, Methoden, Eigenschaften, Felder und mehr statisch sein
		\item Von einer statischen Klasse kann keine Instanz erzeugt werden
		\begin{itemize}
			\item Diese wird automatisch bei Programmstart angelegt
		\end{itemize}
		\item Statische Member existieren außerhalb eines Objektes einer Klasse
		\begin{itemize}
			\item Werden über die Klasse/Datentyp aufgerufen
			\item Können nicht auf nicht-statische Member der zugehörigen Klasse zugreifen
		\end{itemize}
	\end{itemize}
	\textbf{readonly}\\
	\begin{itemize}
		\item Kann nur auf Felder benutzt werden
		\item Stellt sicher, dass das Feld im Laufe der Benutzung nicht verändert wird
		\item Der Wert des Feldes kann nur durch direkte Deklaration oder in einem Konstruktor der zugehörigen Klasse initialisiert werden
	\end{itemize}
\end{frame}

\begin{frame}{Schlüsselwörter}
	\lstinputlisting{resources/05_null_exceptions_schluesselwoerter/static_readonly.cs}
\end{frame}

\begin{frame}{Schlüsselwörter}
	\textbf{var}\\
	\begin{itemize}
		\item Kann für Variablen innerhalb von Methoden genutzt werden
		\item Dabei wird der Datentyp der Variable durch den Compiler bestimmt
		\begin{itemize}
			\item Der Datentyp muss zur Compilezeit bekannt sein
		\end{itemize}
		\item Syntax:
		\begin{itemize}
			\item \texttt{var \alert{<Variablenname>} = \alert{<Eine Zuweisung>};}
		\end{itemize}
		\item Man sollte es nur nutzen, wenn man durch die rechte Seite erkennt, was für ein Typ zugewiesen wird
	\end{itemize}
	\lstinputlisting{resources/05_null_exceptions_schluesselwoerter/var.cs}
\end{frame}

\end{document}
