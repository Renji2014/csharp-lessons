% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Datenstrukturen}
\date{\today}


\begin{document}

\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}

% ----------------------- Enummeration ------------------------------
\section{Enumeration}
\begin{frame}{Enumeration}
	\begin{itemize}
		\item Zu dt. Aufzählung
		\item Das Schlüsselwort dafür ist \alert{enum}
		\item Ist ein eigen erstellter Datentyp mit fester Anzahl konstanter Werte
		\item Den Werten werden Intern ein \alert{int}-Wert zugeordnet
		\begin{itemize}
			\item Diese beginnt Standardmäßig bei 0 und wird mit jedem neuen Element um 1 erhöht
			\item Diese Ordnung kann man auch selbst mit einem \alert{=} festlegen
			\item Man kann damit ein \alert{enum}-Wert in einen \alert{int}-Wert casten			
		\end{itemize}
		\item Syntax zur Nutzung:
		\begin{itemize}
			\item \texttt{\alert{<Enum> <Variablenname>} = \alert{<Enum>}.\alert{<Enumwert>};} oder
			\item \texttt{\alert{<Enum> <Variablenname>} = \alert{<Int-Wert>};}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Enumeration}
	\lstinputlisting{resources/06_datenstrukturen/enum_creation.cs}
	\lstinputlisting{resources/06_datenstrukturen/enum_using.cs}
\end{frame}

% ----------------------- Structs ------------------------------
\section{Structs}
\begin{frame}{Structs}
	\begin{itemize}
		\item Schlüsselwort ist \alert{struct}
		\item Lass sich genauso schreiben wie Klassen
		\item Sie sind nicht Referenz-, sondern Werttypen
		\item Werden genutzt um kleine Gruppen verwandter Variablen zusammen zufassen
		\item Sie können von Interfaces, aber nicht von anderen Structs erben 
	\end{itemize}
\end{frame}

\begin{frame}{Structs}
	\lstinputlisting{resources/06_datenstrukturen/struct_creation.cs}
	\lstinputlisting{resources/06_datenstrukturen/struct_using.cs}
\end{frame}

% ----------------------- Generics ------------------------------
\section{Generics}
\begin{frame}{Generics}
	\begin{itemize}
		\item Auch Typparameter genannt
		\item Ermöglicht es die Angabe von Typen in einer Klasse oder Methode zu verzögern
		\item Syntax:
		\begin{itemize}
			\item \texttt{class \alert{<Klassenname>} <\alert{<Typparameter>}> \{ \}}
		\end{itemize}
	\end{itemize}
	\textbf{Einschränkungen}\\
	\begin{itemize}
		\item Man kann den Typparameter auch einschränken
		\item Syntax:
		\begin{itemize}
			\item \texttt{\alert{<Klassenkopf>} where \alert{<Typparameter>} : \alert{<Einschränbkung>} \{ \}}
		\end{itemize}
		\item Einschränkungen können sein:
		\begin{itemize}
			\item Basisklasse, Interfaces
			\item struct (Werttyp), class (Referenztyp)
			\item new() (Typparameter muss einen öffentlichen, leeren Konstruktor haben)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Generics}
	\lstinputlisting{resources/06_datenstrukturen/generics_creation.cs}
	\lstinputlisting{resources/06_datenstrukturen/generics_using.cs}
\end{frame}

% ----------------------- Collections ------------------------------
\section{Collections}
\begin{frame}{Collections}
	\begin{itemize}
		\item Sind in dem Framework vorhandene Klasse
		\item Dienen zur Auflistung von beliebigen Elementen
		\item Bieten Methoden zum Sortieren, Durchsuchen und Bearbeiten
		\begin{itemize}
			\item Nutzen dafür Generics
		\end{itemize}
		\item Haben eine dynamische Größe, können somit während der Ausführung schrumpfen und wachsen
		\item Namespace:
		\begin{itemize}			
			\item \alert{System.Collection.Generic}
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection{List}
\begin{frame}{List}
	\begin{itemize}
		\item Eine Liste beliebiger Elemente
		\item Kann über einen Index angesteuert werden (ähnlich zum Array)
	\end{itemize}
	\lstinputlisting{resources/06_datenstrukturen/list.cs}
\end{frame}

\subsection{Dictionary}
\begin{frame}{Dictionary}
	\begin{itemize}
		\item Ein "Lexikon" von Paaren mit beliebigen Schlüssel und Wert
		\item Jeder Schlüssel kann nur genau einmal vorkommen
		\item Kann ebenfalls, ähnlich zum Array, angesprochen werden, aber dieses mal wird ein Schlüssel übergeben
	\end{itemize}
	\lstinputlisting{resources/06_datenstrukturen/dictionary.cs}
\end{frame}

\subsection{Weitere}
\begin{frame}{Weitere}
	\textbf{Stack}\\
	\begin{itemize}
		\item Ein "Stapel" an Elementen
		\item Arbeitet nach dem LIFO-Prinzip
		\item \alert{.Push()} (Hinzufügen eines Elementes), \alert{.Pop()} (Entfernen eines Elementes)
	\end{itemize}
	\lstinputlisting{resources/06_datenstrukturen/stack.cs}
	\textbf{Queue}\\
	\begin{itemize}
		\item Eine "Schlange" an Elementen
		\item Arbeitet nach dem FIFO-Prinzip
		\item \alert{.Enqueue()} (Hinzufügen eines Elementes), \alert{.Dequeue()} (Entfernen eines Elementes)
	\end{itemize}
	\lstinputlisting{resources/06_datenstrukturen/queue.cs}
\end{frame}

% ----------------------- Indexer ------------------------------
\section{Indexer}
\begin{frame}{Indexer}
	\begin{itemize}
		\item Sind Member einer Klasse
		\item Geben die Möglichkeit wie ein/e Array/Collection über \alert{[ ]} angesprochen zu werden
		\item Syntax:
		\begin{itemize}
			\item \texttt{\alert{<Typ>} this[\alert{<Indextyp> <Indexname>}]\\ \{ get \{ \alert{<Code>} \} set \{ \alert{<Code>}\} \}}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Indexer}
	\lstinputlisting{resources/06_datenstrukturen/indexer.cs}
\end{frame}

\end{document}
